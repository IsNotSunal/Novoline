package cc.novoline.modules.exploits;

import cc.novoline.events.EventTarget;
import cc.novoline.events.events.TickUpdateEvent;
import cc.novoline.gui.screen.setting.Manager;
import cc.novoline.gui.screen.setting.Setting;
import cc.novoline.gui.screen.setting.SettingType;
import cc.novoline.modules.AbstractModule;
import cc.novoline.modules.EnumModuleType;
import cc.novoline.modules.ModuleManager;
import cc.novoline.modules.configurations.annotation.Property;
import cc.novoline.modules.configurations.property.object.PropertyFactory;
import cc.novoline.modules.configurations.property.object.StringProperty;
import cc.novoline.utils.RotationUtil;
import cc.novoline.utils.notifications.NotificationType;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3;
import org.jetbrains.annotations.NotNull;
import org.lwjgl.input.Mouse;

public class ClickTeleport extends AbstractModule {

    private boolean keyUp;

    @Property("mode")
    private StringProperty mode = PropertyFactory.createString("Toggle").acceptableValues("Toggle", "Middle Click");

    public ClickTeleport(@NotNull ModuleManager moduleManager) {
        super(moduleManager, "ClickTeleport", "Click Teleport", EnumModuleType.EXPLOITS, "lol");
        Manager.put(new Setting("CT_MODE", "Mode", SettingType.COMBOBOX, this, mode));
    }

    private Vec3 getPositionEyes(float partialTicks) {
        return new Vec3(mc.player.posX, mc.player.posY + mc.player.getEyeHeight(), mc.player.posZ);
    }

    public MovingObjectPosition getPosition() {
        float distance = 50;
        Vec3 positionEyes = getPositionEyes(1);
        Vec3 startVec = RotationUtil.getVectorForRotation(mc.player.rotationPitch, mc.player.rotationYaw);
        Vec3 endVec = positionEyes.addVector(startVec.xCoord * distance, startVec.yCoord * distance, startVec.zCoord * distance);
        return mc.world.rayTraceBlocks(positionEyes, endVec, false, false, false);
    }

    @Override
    public void onEnable() {
        if (mode.equals("Toggle")) {
            teleport();
            toggle();
        }
    }

    @EventTarget
    public void onMotion(TickUpdateEvent event) {
        if (mc.player != null) {
            if (mode.equals("Middle Click")) {
                if (Mouse.isButtonDown(2)) {
                    if (keyUp) {
                        teleport();
                        keyUp = false;
                    }

                } else {
                    keyUp = true;
                }
            }
        }
    }


    private void teleport() {
        double maximumStepDistance = mc.player.getBaseMoveSpeed();

        if (getPosition() != null) {
            if (getPosition().typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
                BlockPos pos = getPosition().getBlockPos();
                double x = pos.getX() + 0.5, z = pos.getZ() + 0.5;
                float angleYaw = RotationUtil.getYawToPoint(x, z);
                double distance = Math.abs(mc.player.getDistance(x, pos.getY(), z));
                double height = mc.player.posY;

                for (double step = maximumStepDistance; step < distance; step += maximumStepDistance) {
                    double xAxis = -Math.sin(Math.toRadians(angleYaw)) * step;
                    double zAxis = Math.cos(Math.toRadians(angleYaw)) * step;
                    double distanceToBlock = 0;

                    Vec3 position = getPositionForVector(mc.player.posX + xAxis, height, mc.player.posZ + zAxis);
                    Vec3 sv = RotationUtil.getVectorForRotation(90, 0);
                    Vec3 ed = position.addVector(sv.xCoord * 99, sv.yCoord * 99, sv.zCoord * 99);
                    MovingObjectPosition bh = mc.world.rayTraceBlocks(position, ed, false, false, false);

                    if (bh == null) {
                        novoline.getNotificationManager().pop("Can't teleport there!", 2000, NotificationType.ERROR);
                        return;
                    }

                    for (double ahead = 0; ahead < maximumStepDistance; ahead += maximumStepDistance / 100) {
                        Vec3 startVec = RotationUtil.getVectorForRotation(0, angleYaw);
                        Vec3 endVec = position.addVector(startVec.xCoord * ahead, startVec.yCoord * ahead, startVec.zCoord * ahead);
                        MovingObjectPosition blockAhead = mc.world.rayTraceBlocks(position, endVec, false, false, false);

                        if (blockAhead != null) {
                            if (blockAhead.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
                                distanceToBlock = ahead;
                                break;
                            }
                        }
                    }

                    Block block = mc.world.getBlockState(new BlockPos(
                            mc.player.posX - Math.sin(Math.toRadians(angleYaw)) * (step + maximumStepDistance),
                            height,
                            mc.player.posZ + Math.cos(Math.toRadians(angleYaw)) * (step + maximumStepDistance)))
                            .getBlock();


                    if (distanceToBlock > 0 && block != Blocks.tallgrass) {
                        double dOffsetX = -Math.sin(Math.toRadians(angleYaw)) * (distanceToBlock - 0.3);
                        double dOffsetZ = Math.cos(Math.toRadians(angleYaw)) * (distanceToBlock - 0.3);

                        sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis + dOffsetX, height, mc.player.posZ + zAxis + dOffsetZ,
                                isOnGround(height)));

                        double blockHeight = block == Blocks.air ? 0.5 : block.getBlockBoundsMaxY() - block.getBlockBoundsMinY();
                        double stepHeight = blockHeight - height % 1;

                        if (stepHeight < 0.625) {
                            sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis + dOffsetX, height + stepHeight, mc.player.posZ + zAxis + dOffsetZ, isOnGround(height + stepHeight)));
                        } else {
                            sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis + dOffsetX, height + 0.41999998688698, mc.player.posZ + zAxis + dOffsetZ, false));
                            sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis + dOffsetX, height + 0.7531999805212, mc.player.posZ + zAxis + dOffsetZ, false));
                        }

                        height += stepHeight;
                    } else {
                        double fallDistance = 0;
                        Vec3 newPos = getPositionForVector(mc.player.posX + xAxis, height, mc.player.posZ + zAxis);

                        for (double downCast = 0; downCast < 99; downCast += 0.0001) {
                            Vec3 startVec = RotationUtil.getVectorForRotation(90, 0);
                            Vec3 endVec = newPos.addVector(startVec.xCoord * downCast, startVec.yCoord * downCast, startVec.zCoord * downCast);
                            MovingObjectPosition blockBelow = mc.world.rayTraceBlocks(newPos, endVec,
                                    false,
                                    false,
                                    false);
                            if (blockBelow != null) {
                                if (blockBelow.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
                                    Block block1 = mc.world.getBlockState(blockBelow.getBlockPos()).getBlock();
                                    if (block1 != Blocks.tallgrass) {
                                        fallDistance = MathHelper.incValue(MathHelper.round(downCast, 3), 0.125);
                                        break;
                                    }
                                }
                            }
                        }

                        if (fallDistance > 0) {
                            double forwardMotion = 0;
                            Vec3 trollPosition = getPositionForVector(mc.player.posX + xAxis, height - 0.01, mc.player.posZ + zAxis);
                            for (double forwardCast = 0; forwardCast < maximumStepDistance; forwardCast += 0.001) {
                                Vec3 startVec = RotationUtil.getVectorForRotation(0, angleYaw);
                                Vec3 endVec = trollPosition.addVector(startVec.xCoord * forwardCast, startVec.yCoord * forwardCast, startVec.zCoord * forwardCast);
                                MovingObjectPosition blockBelow = mc.world.rayTraceBlocks(trollPosition, endVec,
                                        false,
                                        false,
                                        false);
                                if (blockBelow != null) {
                                    if (blockBelow.typeOfHit != MovingObjectPosition.MovingObjectType.BLOCK) {
                                        forwardMotion = forwardCast;
                                    }
                                }
                            }

                            double fwX = -Math.sin(Math.toRadians(angleYaw)) * (forwardMotion + 0.5);
                            double fwZ = Math.cos(Math.toRadians(angleYaw)) * (forwardMotion + 0.5);

                            sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis + fwX, height, mc.player.posZ + zAxis + fwZ,
                                    isOnGround(height)));

                            double fell = 0;
                            double downMotion = 0;
                            double midAirPosition = height;

                            for (int i = 0; i < 99; i++) {
                                if (fell < fallDistance) {
                                    downMotion += 0.08;
                                    downMotion *= 0.980000019073486;
                                    fell += downMotion;
                                    midAirPosition = height - fell;

                                    if (fell < fallDistance) {
                                        sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis + fwX, midAirPosition, mc.player.posZ + zAxis + fwZ, isOnGround(midAirPosition)));
                                    }

                                } else {
                                    height -= fallDistance;
                                    break;
                                }
                            }

                        } else {
                            sendPacketNoEvent(new C04PacketPlayerPosition(mc.player.posX + xAxis, height, mc.player.posZ + zAxis, isOnGround(height)));
                        }
                    }
                }

                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                sendPacketNoEvent(new C03PacketPlayer(false));
                mc.player.setPosition(x, height, z);
            }
        }
    }

    public Vec3 getPositionForVector(double x, double y, double z) {
        return new Vec3(x, y, z);
    }

    private boolean isOnGround(double posY) {
        return posY % 1 == 0.015625 || posY % 0.125 == 0;
    }
}
